// ==========================================================================
//                      DG.GlobalFormulaContext
//  
//  Author:   Kirk Swenson
//
//  Copyright (c) 2014 by The Concord Consortium, Inc. All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
// ==========================================================================

sc_require('formula/formula_context');

/** @class DG.GlobalFormulaContext

  DG.FormulaContext objects support DG.Formula objects by providing identifier
  binding and evaluation, function binding and evaluation, etc.
  The DG.GlobalFormulaContext class adds binding to global (slider) values.

  @extends DG.FormulaContext
*/
DG.GlobalFormulaContext = DG.FormulaContext.extend({

  /**
    Initialization method.
    Adds observer for global value changes.
   */
  init: function() {
    sc_super();
    DG.globalsController.addObserver('globalNameChanges', this, 'globalNamesDidChange');
    DG.globalsController.addObserver('globalValueChanges', this, 'globalValuesDidChange');
  },
  
  /**
    Destruction method.
    Removes observer for global value changes.
   */
  destroy: function() {
    DG.globalsController.removeObserver('globalNameChanges', this, 'globalNamesDidChange');
    DG.globalsController.removeObserver('globalValueChanges', this, 'globalValuesDidChange');
    sc_super();
  },
  
  /**
    Compiles a variable reference into the JavaScript code for accessing
    the appropriate value. For the PlottedFunctionContext, this means
    binding to 'x' and any global values (e.g. sliders).
    @param    {String}    iName -- The variable name to be bound
    @returns  {String}    The JavaScript code for accessing the value
    @throws   {VarReferenceError} Base class throws VarReferenceError for
                                  variable names that are not recognized.
   */
  compileVariable: function( iName) {
  
    // Check for a match with any global variables (e.g. sliders)
    var global = DG.globalsController.getGlobalValueByName( iName);
    if( global) {
      // Having identified the global value to be referenced, we attach
      // a function that can access the appropriate value, making use of
      // JavaScript variable scoping to make sure that the new function has
      // access to the local variable named 'global'. We attach this function
      // to a map of referenced global variables in the context named 'g'.
      // (This is code that is generated by the app for the express purpose
      // of machine consumption, so we use terse variable names for simplicity.)
      // The generated JavaScript code then executes the function dereferenced
      // from the context with code that looks something like 'return c.g["v1"]'.
      if( !this.g) this.g = {};
      this.g[iName] = function() {
                        return global.get('value');
                      };
      return 'c.g["' + iName + '"]()';
    }

    // If we don't match any variables we're in charge of,
    // let the base class have a crack at it.
    return sc_super();
  },
  
  /**
    Direct evaluation of the expression without an intervening compilation.
    This is unlikely to be used for plotted funtions where the expression is
    generally evaluated enough times to make compilation to JavaScript
    worthwhile, but we support it for consistency and completeness.
    @param    {String}    iName -- The variable name to be bound
    @returns  {Number}            The value of the specified variable or global
    @throws   {VarReferenceError} Base class throws VarReferenceError for
                                  variable names that are not recognized.
   */
  evaluateVariable: function( iName, iEvalContext) {

    // Check for a match with any global variables (e.g. sliders)
    var global = DG.globalsController.findGlobalByName( iName);
    if( global) {
      this.g[ iName] = true;  // add entry in map for dependency tracking
      return global.get('value');
    }

    // If we don't match any variables we're in charge of,
    // let the base class have a crack at it.
    return sc_super();
  },
  
  /**
    Observer method called when global value names (e.g. sliders)
    are change, e.g. created, deleted, or renamed. Formulas must
    recompile in case they are affected by the name changes.
    Sends out a 'dependentChange' notification to notify clients.
   */
  globalNamesDidChange: function() {
    // Eventually, we can be more selective, e.g. only notify
    // if there are unbound names in the formula, but for now
    // we assume that all name changes require notification.
    this.notifyPropertyChange('namespaceChange');
  },

  /**
    Observer method called when global values (e.g. sliders) change.
    This method determines whether the formula is affected based on
    whether the global values that are referenced in the formula are
    among those whose value changed. If so, we notify by sending out
    a 'dependentChange' notification.
   */
  globalValuesDidChange: function() {
    // Get the list of global values that have changed
    var changes = DG.globalsController.get('globalValueChanges'),
        i, changeCount = changes && changes.length;
    // Loop through the list to see if we reference any of them
    for( i = 0; i < changeCount; ++i) {
      // If we have an entry in our 'g' map, then we have a reference.
      if( this.g && this.g[ changes[i]]) {
        this.notifyPropertyChange('dependentChange');
        return;
      }
    }
  }
  
 });

