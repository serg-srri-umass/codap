// ==========================================================================
//                            DG.Formula
//  
//  Author:   Kirk Swenson
//
//  Copyright (c) 2014 by The Concord Consortium, Inc. All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
// ==========================================================================

sc_require('formula/formula_common');
sc_require('formula/formula_context');

/** @class DG.Formula

  The DG.Formula object supports parsing, compilation, and evaluation of
  mathematical expressions. They make use of DG.FormulaContexts to provide
  variable and function references in different contexts.

  @extends SC.Object
 */
DG.Formula = SC.Object.extend({

  /**
    The compilation/evaluation context for the formula.
    @property   {DG.FormulaContext}
   */
  context: null,

  /**
    The original source text for the formula.
    @property   {String}
   */
  source: null,
  
  /**
    Initialization function.
   */
  init: function() {
    sc_super();
    
    // Observe our context for dependent changes.
    var context = this.get('context');
    if( context) context.addObserver('namespaceChange', this, 'namespaceDidChange');
    if( context) context.addObserver('dependentChange', this, 'dependentDidChange');
  },
  
  /**
    Destruction function.
   */
  destroy: function() {
    var context = this.get('context');
    if( context) {
      // Remove observation of context
      context.removeObserver('namespaceChange', this, 'namespaceDidChange');
      context.removeObserver('dependentChange', this, 'dependentDidChange');
      context.destroy();
      this.context = null;
    }
    sc_super();
  },
  
  /**
    Force a recompilation/reevaluation, including re-parsing the expression.
   */
  invalidate: function() {
    this.notifyPropertyChange('source');
  },
  
  /**
    Force a recompilation/reevaluation, without a re-parsing the expression.
   */
  invalidateContext: function() {
    this.notifyPropertyChange('context');
  },
  
  /**
    Observer function called when the context signals that its namespace
    has changed, which generally means that recompilation is required.
    This function just propagates the notification to clients of the formula.
   */
  namespaceDidChange: function( iNotifier, iKey) {
    this.notifyPropertyChange( iKey);
    // For some clients, just knowing that a dependent may have changed is sufficient.
    this.notifyPropertyChange('dependentChange');
  },
  
  /**
    Observer function called when the context signals that one of its
    dependents has changed. This generally means that reevaluation is
    required, but that recompilation is not. This function generally
    just propagates the notification to clients of the formula.
   */
  dependentDidChange: function( iNotifier, iKey) {
    this.notifyPropertyChange( iKey);
  },
  
  /**
    The output of the PEG.js parser for the formula
    @property   {Object}
   */
  parseCount: 0,
  parsed: function() {
    ++ this.parseCount;
    var source = this.get('source'),
        result;
    try {
      result = source && DG.formulaParser.parse( source);
    }
    catch( err) {
      // Replace the PEG.js-generated SyntaxError message with our own
      err.originalMessage = err.message;
      err.message = err.found ? 'DG.Formula.SyntaxErrorMiddle'.loc( err.found)
                              : 'DG.Formula.SyntaxErrorEnd'.loc();
      throw err;
    }
    return result;
  }.property('source').cacheable(),
  
  /**
    The JavaScript function generated by walking the parse tree and generating code.
   */
  compiled: function() {
    var parsed = this.get('parsed'),
        context = this.get('context'),
        compiled = null;
    if( !context) {
      context = DG.FormulaContext.create({});
      this.context = context; // no reason to notify, so no set()
    }
    if( parsed) {
      context.clearCaches();
      var output = DG.Formula.compileToJavaScript( parsed, context);
      compiled = DG.FormulaContext.createContextFunction( output);
    }
    return compiled;
  }.property('parsed','context','namespaceChange').cacheable(),
  
  /**
    Returns true if this formula contains aggregate functions, false otherwise.
    @property {Boolean}
   */
  hasAggregates: function() {
    var hasAggregates = false;
    // Trap any parse errors that might occur
    try {
      // Make sure compilation has occurred. Shouldn't cause extra compilations
      // unless the SproutCore caching model isn't working as expected.
      this.get('compiled');
    
      var context = this.get('context');
      if( context)
        hasAggregates = context.get('hasAggregates');
    }
    catch(e) {
      // Formulas with parse errors can't cause aggregate function
      // evaluation, therefore we can simply swallow the parse error.
    }
    return hasAggregates;
  }.property('compiled', 'context').cacheable(),
  
  /**
    Evaluates the expression by compiling it to an intermediate JavaScript
    representation which is then used to create a new Function(...) for
    evaluation. This provides greater performance for formulas that are
    evaluated many times. For formulas that are only evaluated a few times,
    however, the overhead of compilation exceeds any benefit, and so
    evaluateDirect() should be used in those situations.
    @param    {Object}    iEvalContext -- An evaluation context object which allows
                                          clients to pass evaluation-time values to
                                          the evaluation process.
    @returns  {Object}    The evaluated result
   */
  evaluate: function( iEvalContext) {
    var compiled = this.get('compiled'),
        context = this.get('context');
    return compiled && compiled( context, iEvalContext);
  },
  
  /**
    Evaluates the expression directly without compilation.
    This is more efficient for small numbers of evaluations than the
    compile-to-JavaScript mechanism used by evaluate(), but is inefficient
    for large numbers of evaluations.
    @param    {Object}    iEvalContext -- An evaluation context object which allows
                                          clients to pass evaluation-time values to
                                          the evaluation process.
    @returns  {Object}    The evaluated result
   */
  evaluateDirect: function( iEvalContext) {
    var parsed = this.get('parsed'),
        context = this.get('context');
    if( !context) {
      context = DG.FormulaContext.create({});
      this.context = context; // no reason to notify, so no set()
    }
    return DG.Formula.evaluateParseTree( parsed, context, iEvalContext);
  }
  
  //@if(debug)
  /**
    Returns an array of parse tree nodes which can be processed iteratively
    without any recursion. Part of an experimental evaluation model which 
    never panned out. See evaluatePostfix() for details.
   */
  , postfix: function() {
    var parsed = this.get('parsed'),
        context = this.get('context');
    if( !context) {
      context = DG.FormulaContext.create({});
      this.context = context; // no reason to notify, so no set()
    }
    return DG.Formula.convertToPostfix( parsed, context);
  }.property('parsed','context').cacheable()
  
  /**
    An experimental evaluation model which converts the parse tree into an array
    which can be processed directly without the recursion required by the parse tree.
    The hypothesis was that there would be a performance penalty in the recursion
    required to walk the infix parse tree, and so pre-processing it into a postfix
    form which eliminated the recursion would show some performance improvement.
    Interestingly, however, performance testing to date has not shown any improvement,
    and the cost of converting to postfix is non-trivial, so we ignore this option.
    @param    {Object}    iEvalContext -- An evaluation context object which allows
                                          clients to pass evaluation-time values to
                                          the evaluation process.
    @returns  {Object}    The evaluated result
   */
  , evaluatePostfix: function( iEvalContext) {
    var postfix = this.get('postfix'),
        context = this.get('context');
    if( !context) {
      context = DG.FormulaContext.create({});
      this.context = context; // no reason to notify, so no set()
    }
    return DG.Formula.evaluatePostfix( postfix, context, iEvalContext);
  }
  //@endif
  
});

/**
  Compiles the specified parse tree results into a JavaScript expression
  which can be used with the specified context to compute the result.
  This function walks the parse tree, converting each node to its JavaScript
  equivalent and then combining the nodes appropriately so that the result 
  is a single JavaScript expression.
  @param    {Object}            The parse tree results from PEG.js
  @param    {DG.FormulaContext} The context object used for variable/function references
  @returns  {String}            A JavaScript expression suitable for evaluation
 */
DG.Formula.compileToJavaScript = function( iParseTree, iContext) {

  var fnMap;

  /**
    Call the appropriate visit function based on the node type.
   */
  function visit( iNode) {
    var fn = fnMap[ iNode.type];
    return fn && fn( iNode);
  }

  function visitLiteral( iNode) {
    return iNode.value;
  }

  function visitStringLiteral( iNode) {
    // Issues with embedded quotes?
    return '"' + iNode.value + '"';
  }

  function visitVariable( iNode) {
    // Pass variable references to the context
    return iContext.compileVariable( iNode.name);
  }
  
  function visitFunctionCall( iNode) {
    var i, len = iNode.args && iNode.args.length,
        args = [];
    for( i = 0; i < len; ++i) {
      args.push( visit( iNode.args[i]));
    }
    // Pass function references to the context
    return iContext.compileFunction( iNode.name.name, args);
  }
  
  function visitTerm( iNode) {
    var useParens = (iNode.type === 'BinaryExpression'),
        expr = visit( iNode);
    if( useParens) expr = '(' + expr + ')';
    return expr;
  }
  
  function visitUnaryExpression( iNode) {
    return iNode.operator + visitTerm( iNode.expression);
  }
  
  function visitBinaryExpression( iNode) {
    var leftTerm = visitTerm( iNode.left),
        rightTerm = visitTerm( iNode.right);
    
    // Convert x^y to Math.pow(x,y)
    if( iNode.operator === '^')
      return 'Math.pow(' + leftTerm + ',' + rightTerm + ')';

    // Standard binary operators
    return leftTerm + iNode.operator + rightTerm;
  }
  
  function visitConditionalExpression( iNode) {
    return '(' + visitTerm( iNode.condition) +
            '?' + visitTerm( iNode.trueExpression) +
            ':' + visitTerm( iNode.falseExpression) + ')';
  }
  
  fnMap = {
    'BooleanLiteral': visitLiteral,
    'NumericLiteral': visitLiteral,
    'StringLiteral': visitStringLiteral,
    'Variable': visitVariable,
    'FunctionCall': visitFunctionCall,
    'UnaryExpression': visitUnaryExpression,
    'BinaryExpression': visitBinaryExpression,
    'ConditionalExpression': visitConditionalExpression
  };
  
  // Recursively visit every node in the parse tree
  return visit( iParseTree);
};

/**
  Evaluates the specified parse tree by walking the tree and evaluating nodes
  recursively. This function walks the parse tree, evaluating each node and then 
  combining the nodes appropriately to come up with the final result.
  @param    {Object}            The parse tree results from PEG.js
  @param    {DG.FormulaContext} The context object used for variable/function references
  @returns  {Object}            The result of evaluation
 */
DG.Formula.evaluateParseTree = function( iParseTree, iContext, iEvalContext) {

  var fnMap;

  function visit( iNode) {
    var fn = fnMap[ iNode.type];
    return fn && fn( iNode);
  }

  function visitLiteral( iNode) {
    return iNode.value;
  }

  function visitVariable( iNode) {
    // Pass variable references to the context
    return iContext.evaluateVariable( iNode.name, iEvalContext);
  }
  
  function visitFunctionCall( iNode) {
    var i, len = iNode.args && iNode.args.length,
        args = [];
    for( i = 0; i < len; ++i) {
      args.push( visit( iNode.args[i]));
    }
    // Pass function references to the context
    return iContext.evaluateFunction( iNode.name.name, args);
  }
  
  function visitUnaryExpression( iNode) {
    var value = visit( iNode.expression);
    switch( iNode.operator) {
    case '+': return +value;
    case '-': return -value;
    case '!': return !value;
    }
    
    // Error: Unrecognized operator! Throw an exception?
    return undefined;
  }
  
  function visitBinaryExpression( iNode) {
    var left = visit( iNode.left),
        right = visit( iNode.right);
    
    switch( iNode.operator) {
    case '^':   return Math.pow( left, right);
    case '*':   return left * right;
    case '/':   return left / right;
    case '%':   return left % right;
    case '+':   return left + right;
    case '-':   return left - right;
    case '<':   return left < right;
    case '>':   return left > right;
    case '<=':  return left <= right;
    case '>=':  return left >= right;
    case '===': return left === right;
    case '!==': return left !== right;
    case '&&':  return left && right;
    case '||':  return left || right;
    }

    // Error: Unrecognized operator! Throw an exception?
    return undefined;
  }
  
  function visitConditionalExpression( iNode) {
    return visit( iNode.condition) ? visit( iNode.trueExpression)
                                   : visit( iNode.falseExpression);
  }
  
  fnMap = {
    'BooleanLiteral': visitLiteral,
    'NumericLiteral': visitLiteral,
    'StringLiteral': visitLiteral,
    'Variable': visitVariable,
    'FunctionCall': visitFunctionCall,
    'UnaryExpression': visitUnaryExpression,
    'BinaryExpression': visitBinaryExpression,
    'ConditionalExpression': visitConditionalExpression
  };
  
  return visit( iParseTree);
};


//@if(debug)
/**
  An experimental evaluation model which converts the parse tree into an array
  which can be processed directly without the recursion otherwise required.
  The hypothesis was that there would be a performance penalty in the recursion
  required to walk the infix parse tree, and so pre-processing it into a postfix
  form which eliminated the recursion would show some performance improvement.
  @param    {Object}            The parse tree results from PEG.js
  @param    {DG.FormulaContext} The context object used for variable/function references
  @returns  {Array}             The array of nodes in postfix evaluation order
 */
DG.Formula.convertToPostfix = function( iParseTree, iContext) {

  var fnMap, postfix = [];

  function visit( iNode) {
    var fn = fnMap[ iNode.type];
    return fn && fn( iNode);
  }

  function visitLeaf( iNode) {
    postfix.push( iNode);
  }

  function visitFunctionCall( iNode) {
    var i, len = iNode.args && iNode.args.length;
    for( i = 0; i < len; ++i) {
      visit( iNode.args[i]);
    }
    postfix.push( iNode);
  }
  
  function visitUnaryExpression( iNode) {
    visit( iNode.expression);
    postfix.push( iNode);
  }
  
  function visitBinaryExpression( iNode) {
    visit( iNode.left);
    visit( iNode.right);
    postfix.push( iNode);
  }
  
  function visitConditionalExpression( iNode) {
    visit( iNode.condition);
    visit( iNode.trueExpression);
    visit( iNode.falseExpression);
    postfix.push( iNode);
  }
  
  fnMap = {
    'BooleanLiteral': visitLeaf,
    'NumericLiteral': visitLeaf,
    'StringLiteral': visitLeaf,
    'Variable': visitLeaf,
    'FunctionCall': visitFunctionCall,
    'UnaryExpression': visitUnaryExpression,
    'BinaryExpression': visitBinaryExpression,
    'ConditionalExpression': visitConditionalExpression
  };
  
  visit( iParseTree);
  return postfix;
};


/**
  An experimental evaluation model which converts the parse tree into an array
  which can be processed directly without the recursion otherwise required.
  The hypothesis was that there would be a performance penalty in the recursion
  required to walk the infix parse tree, and so pre-processing it into a postfix
  form which eliminated the recursion would show some performance improvement.
  @param    {Object}            The parse tree results from PEG.js
  @param    {DG.FormulaContext} The context object used for variable/function references
  @returns  {Array}             The array of nodes in postfix evaluation order
 */
DG.Formula.evaluatePostfix = function( iPostfix, iContext) {

  var fnMap, stack = new Array(iPostfix.length), slen = 0;

  function visit( iNode) {
    var fn = fnMap[ iNode.type];
    return fn && fn( iNode);
  }

  function visitLiteral( iNode) {
    stack[slen++] = iNode.value;
  }

  function visitVariable( iNode) {
    stack[slen++] = iContext.evaluateVariable( iNode.name);
  }
  
  function visitFunctionCall( iNode) {
    var nArgs = iNode.args && iNode.args.length,
        stackArgs = nArgs ? stack.slice( slen - nArgs, slen) : [],
        result = iContext.evaluateFunction( iNode.name.name, stackArgs);
    slen -= nArgs-1;
    stack[slen-1] = result;
  }
  
  function visitUnaryExpression( iNode) {
    if( !slen) return undefined;
    
    var result, value = stack[slen-1];
    switch( iNode.operator) {
    case '+': result = +value; break;
    case '-': result = -value; break;
    case '!': result = !value; break;
    }
    
    stack[slen-1] = result;
  }
  
  function visitBinaryExpression( iNode) {
    if( slen < 2) return undefined;
    
    var left = stack[slen-2],
        right = stack[slen-1],
        result;
    switch( iNode.operator) {
    case '^':   result = Math.pow( left, right);  break;
    case '*':   result = left * right;  break;
    case '/':   result = left / right;  break;
    case '%':   result = left % right;  break;
    case '+':   result = left + right;  break;
    case '-':   result = left - right;  break;
    case '<':   result = left < right;  break;
    case '>':   result = left > right;  break;
    case '<=':  result = left <= right; break;
    case '>=':  result = left >= right; break;
    case '===': result = left === right; break;
    case '!==': result = left !== right; break;
    case '&&':  result = left && right; break;
    case '||':  result = left || right; break;
    }
    
    --slen;
    stack[slen-1] = result;
  }
  
  function visitConditionalExpression( iNode) {
    if( slen < 3) return undefined;
    
    var condition = stack[slen-3],
        trueExp = stack[slen-2],
        falseExp = stack[slen-1];
    slen -= 2;
    stack[slen-1] = condition ? trueExp : falseExp;
  }
  
  fnMap = {
    'BooleanLiteral': visitLiteral,
    'NumericLiteral': visitLiteral,
    'StringLiteral': visitLiteral,
    'Variable': visitVariable,
    'FunctionCall': visitFunctionCall,
    'UnaryExpression': visitUnaryExpression,
    'BinaryExpression': visitBinaryExpression,
    'ConditionalExpression': visitConditionalExpression
  };
  
  iPostfix.forEach( function( iNode) { visit( iNode); });
  return slen > 0 ? stack[slen-1] : undefined;
};
//@endif
